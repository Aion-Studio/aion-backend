datasource db {
  provider = "postgresql"
  url      = env("PRISMA__DATABASE__URL")
}

generator client {
  provider = "cargo prisma"
  output   = "../src/prisma.rs"
  // uncomment below for js client seed scripts
  // provider = "prisma-client-js"
}

model Account {
  id             String   @id @default(uuid())
  supabaseUserId String   @unique @map("supabase_user_id") // Reference to the user data on Supabase
  heroes         Hero[]
  createdAt      DateTime @default(now()) @map("created_at")
  updatedAt      DateTime @default(now()) @map("updated_at")
}

model Hero {
  id              String            @id @default(uuid())
  class           Class
  hitpoints       Int
  strength        Int
  dexterity       Int
  intelligence    Int
  explore         Int
  stamina         Int
  crafting        Int
  relics          Relic[]
  spells          Spell[]
  Account         Account?          @relation(fields: [accountId], references: [id])
  accountId       String?
  HeroResource    HeroResource[]
  HeroActions     HeroActions[]
  HeroQuests      HeroQuests[]
  ActionCompleted ActionCompleted[]
  HeroRegion      HeroRegion[]
  HeroCard        HeroCard[]
  Deck            Deck[]
}

enum Class {
  Fighter
  Ranger
  Wizard
}

model Relic {
  id      String        @id @default(uuid())
  name    String
  effects RelicEffect[]
  heroId  String
  hero    Hero          @relation(fields: [heroId], references: [id])
}

model RelicEffect {
  id       String     @id @default(uuid())
  type     EffectType // Enum for type of effect
  value    Int
  target   String // Target of the effect, e.g., "self" or "enemy"
  duration Int? // Duration in turns, if applicable
  relicId  String
  relic    Relic      @relation(fields: [relicId], references: [id])
}

enum EffectType {
  Heal
  Damage
  Buff
  Debuff
  ApplySpell
}

model Spell {
  id     String @id @default(uuid())
  name   String
  slot   Int // Slot number, e.g., 1, 2, 3
  level  Int // Required level to unlock
  heroId String
  hero   Hero   @relation(fields: [heroId], references: [id])
}

model HeroResource {
  id             String       @id @default(uuid())
  heroId         String       @map("hero_id")
  hero           Hero         @relation(fields: [heroId], references: [id])
  resource       ResourceType @relation(fields: [resourceTypeId], references: [id])
  amount         Int
  resourceTypeId String       @map("resource_type_id")

  @@unique([heroId, resourceTypeId])
}

model Action {
  id          String  @id @default(uuid())
  name        String
  description String?
  region_name String  @map("region_name")
  Region      Region  @relation(fields: [region_name], references: [name])

  // Optional fields for Leyline and Quest
  leyline   Leyline? @relation(fields: [leylineId], references: [id])
  leylineId String?  @map("leyline_id")
  quest     Quest?   @relation(fields: [questId], references: [id])
  questId   String?  @map("quest_id")

  npc   Npc?    @relation("ActionToNpc", fields: [npcId], references: [id])
  npcId String? @map("npc_id")

  heroAction HeroActions[]

  cost Int? @default(0)

  @@unique([name, description, questId])
}

model HeroActions {
  id       String @id @default(uuid())
  heroId   String @map("hero_id")
  hero     Hero   @relation(fields: [heroId], references: [id])
  actionId String @map("action_id")
  action   Action @relation(fields: [actionId], references: [id])
}

model Quest {
  id             String       @id @default(uuid())
  title          String
  region_name    String       @map("region_name")
  Region         Region       @relation(fields: [region_name], references: [name])
  requiredQuests Quest[]      @relation("QuestRequirements")
  requiredBy     Quest[]      @relation("QuestRequirements")
  questNumber    Int
  actions        Action[]
  heroQuests     HeroQuests[]
  cost           Int          @default(0)
}

model HeroQuests {
  id        String  @id @default(uuid())
  heroId    String  @map("hero_id")
  hero      Hero    @relation(fields: [heroId], references: [id])
  questId   String  @map("quest_id")
  quest     Quest   @relation(fields: [questId], references: [id])
  accepted  Boolean @default(false)
  completed Boolean @default(false)
}

model ActionCompleted {
  id          String   @id @default(uuid())
  actionName  String   @map("action_name")
  heroId      String   @map("hero_id")
  hero        Hero     @relation(fields: [heroId], references: [id])
  updatedAt   DateTime @default(now()) @map("updated_at")
  createdAt   DateTime @default(now()) @map("created_at")
  completedAt DateTime @default(now()) @map("completed_at")
  lootBox     Json     @default("{}") //
}

model HeroRegion {
  id               String  @id @default(uuid())
  HeroId           String  @map("hero_id")
  discovery_level  Float   @map("discovery_level")
  Hero             Hero    @relation(fields: [HeroId], references: [id])
  Region           Region  @relation(fields: [region_name], references: [name])
  region_name      String  @map("region_name")
  current_location Boolean @default(false) @map("current_location")
}

model ResourceType {
  id           String         @id @default(uuid())
  type         Resource
  HeroResource HeroResource[]

  @@unique([type])
}

enum Resource {
  Aion
  Flux
  Gem
}

model ResourceCost {
  id       String   @id @default(uuid())
  resource Resource
  amount   Int
}

model Region {
  name             String       @id
  adjacent_regions String[]
  HeroRegion       HeroRegion[]
  Leylines         Leyline[]
  Actions          Action[]
  Quests           Quest[]
}

model Leyline {
  id                 String @id @default(uuid())
  name               String
  xp_reward          Int    @map("xp_reward")
  RegionName         String
  Region             Region @relation(fields: [RegionName], references: [name])
  discovery_required Int
  stamina_rate       Float
  aion_rate          Float

  npcId String @unique
  npc   Npc    @relation("NpcToLeyline", fields: [npcId], references: [id])

  actions Action[] // This will relate Leyline to many Actions
}

model Npc {
  id        String @id @default(uuid())
  name      String
  level     Int
  armor     Int    @default(0)
  strength  Int
  damageMin Int    @default(0)
  damageMax Int    @default(0)
  hp        Int    @default(150)

  leyline Leyline? @relation("NpcToLeyline")
  actions Action[] @relation("ActionToNpc")
  Deck    Deck[]
}

model Card {
  id       String       @id @default(uuid())
  name     String
  class    Class // e.g., Attack, Weapon Attack, Heal, Armor, Lifesteal
  cost     Int // Cost to play the card
  effects  CardEffect[] // Relation to CardEffect
  HeroCard HeroCard[]
}

model CardEffect {
  id          String     @id @default(uuid())
  efffectType EffectType // Enum for type of effect
  value       Int
  target      TargetType // Target of the effect, e.g., "self" or "enemy"
  duration    Int? // Duration in turns, if applicable
  cardId      String
  card        Card       @relation(fields: [cardId], references: [id])
}

model HeroCard {
  id       String     @id @default(uuid())
  heroId   String
  cardId   String
  hero     Hero       @relation(fields: [heroId], references: [id])
  card     Card       @relation(fields: [cardId], references: [id])
  DeckCard DeckCard[]
}

model DeckCard {
  id         String    @id @default(uuid())
  deckId     String
  HeroCard   HeroCard? @relation(fields: [heroCardId], references: [id])
  heroCardId String?
}

model Deck {
  id     String  @id @default(uuid())
  name   String  @default("my deck")
  Hero   Hero?   @relation(fields: [heroId], references: [id])
  heroId String?
  Npc    Npc?    @relation(fields: [npcId], references: [id])
  active Boolean @default(false)
  npcId  String?
}

enum TargetType {
  Opponent
  Itself
}

enum Nation {
  Dusane
  Aylen
  Ironmark
  Kelidor
  Meta
}

enum Rarity {
  Common
  Rare
  Epic
  Legendary
}
